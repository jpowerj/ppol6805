---
title: "Week 8: {{< var weeks.8.title >}}"
subtitle: "{{< var course.slides-subtitle >}}"
author: "{{< var course.author >}}"
institute: "{{< var course.institute >}}"
date: "October 16, 2024"
date-format: full
lecnum: 8
categories:
  - "Class Sessions"
bibliography: "../_PPOL6805.bib"
# Shared across formats:
echo: true
code-fold: show
css: "../dsan-globals/jjstyles.css"
html-math-method: mathjax
# Format-specific settings:
format:
  revealjs:
    output-file: "slides.html"
    df-print: kable
    slide-number: true
    scrollable: true
    tbl-cap-location: bottom
    link-external-icon: true
    link-external-newwindow: true
    footer: "{{< var weeks.8.footer >}}"
    include-in-header:
      text: "<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css'>"
    theme: [default]
    revealjs-plugins:
      - simplemenu
    simplemenu:
      flat: true
      barhtml:
        header: "<div class='menubar'><span style='position: absolute; left: 8; padding-left: 8px;'><a href='./index.html'>&larr; Return to Notes</a></span><ul class='menu'></ul></div>"
      scale: 0.5
  html:
    output-file: "index.html"
    html-math-method: mathjax
    df-print: kable
---

::: {.content-visible unless-format="revealjs"}

<center class='mb-3'>
<a class="h2" href="./slides.html" target="_blank">Open slides in new tab &rarr;</a>
</center>

:::

# HW4 Tips!

* `ppp` Objects
* Converting between `ppp` and `sf`
* Plotting

::: {.hidden}

```{r}
#| label: r-source-globals
source("../dsan-globals/_globals.r")
set.seed(6805)
library(tidyverse) |> suppressPackageStartupMessages()
library(sf) |> suppressPackageStartupMessages()
library(spatstat) |> suppressPackageStartupMessages()
```

:::

## [From Last Week] Our New Library: `spatstat`! {.crunch-title}

:::: {.columns}
::: {.column width="50%"}

* Homepage: [spatstat.org](https://spatstat.org/){target='_blank'}
* GitHub: [github.com/spatstat](https://github.com/spatstat){target='_blank'}
* Book: @baddeley_spatial_2015 \[[Companion website](http://book.spatstat.org/){target='_blank'}\]
* PDF: [here](https://www.dropbox.com/scl/fi/egw826hopf6q53ll071n1/Baddeley-Adrian_-Rubak-Ege_-Turner-Rolf-Spatial-point-patterns.pdf?rlkey=y1n4smru4sj43sxzu4x54p5a9&dl=1)

:::
::: {.column width="50%"}

![](images/spatstat_book.jpg){fig-align="center" width="75%"}

:::
::::

## `ppp` Objects {.smaller .crunch-title .crunch-ul .smaller-table}

* The **main** datatype used to represent **P**lanar **P**oint **P**atterns [`spatstat` book p. 41]
* Unlike `sf` objects, which contain data+geometries for any desired collection of $N$ entities, `ppp` objects are **required** to have at least an **observation window**!

:::: {.columns}
::: {.column width="50%"}

`sf` Creation:

```{r}
#| label: sf-creation
tree_df <- tibble::tibble(lon=runif(100,0,1), lat=runif(100,0,1), age=runif(100,0,1))
tree_sf <- sf::st_as_sf(
  tree_df,
  coords = c('lon', 'lat')
)
tree_sf |> head(4)
```

:::
::: {.column width="50%"}

`ppp` Creation:

```{r}
#| label: ppp-creation
pois_ppp <- spatstat.random::rpoispp(
  lambda=100, win=spatstat.geom::square(1)
)
pois_ppp
attributes(pois_ppp)$names
pois_ppp$x |> head(4)
```

:::
::::

## `ppp` $\leftrightarrow$ `sf` Conversion {.smaller .smaller-table .crunch-title .crunch-details}

:::: {.columns}
::: {.column width="50%"}

`ppp` to `sf` Conversion:

```{r}
#| label: ppp-to-sf-conversion
pois_sf <- pois_ppp |> sf::st_as_sf()
pois_sf |> head(4)
```

```{r}
#| label: converted-sf-plot
#| code-fold: true
pois_sf |> ggplot() +
  geom_sf(data=pois_sf |> filter(label=="window"), aes(fill='grey')) +
  geom_sf(data=pois_sf |> filter(label != "window"), aes(color='black')) +
  theme_classic(base_size=28) +
  scale_fill_manual(name=NULL, values=c("gray90"), labels=c("label == 'window'")) +
  scale_color_manual(name=NULL, values=c("black"), labels=c("label == 'point'"))
```

:::
::: {.column width="50%"}

`sf` to `ppp` Conversion:

```{r}
#| label: sf-to-ppp-conversion
square_sfc <- sf::st_polygon(list(
  matrix(c(0,0,1,0,1,1,0,1,0,0), nrow=5, byrow=TRUE)
)) |> sf::st_sfc()
tree_ppp <- as.ppp(
  sf::st_as_sfc(tree_sf),
  W=as.owin(square_sfc)
)
tree_ppp
```

```{r}
#| label: converted-ppp-plot
#| code-fold: true
tree_ppp_sf <- tree_ppp |> sf::st_as_sf()
tree_ppp_sf |> ggplot() +
  geom_sf(aes(fill='gray90')) +
  geom_sf(data=tree_ppp_sf |> filter(label != "window"), aes(color='black')) +
  theme_classic(base_size=28) +
  scale_fill_manual(name=NULL, values=c("gray90"), labels=c("tree_ppp$window")) +
  scale_color_manual(name=NULL, values=c("black"), labels=c("tree_ppp$x, tree_ppp$y"))
```

:::
::::

# Summary Statistics vs. Models {.smaller .smaller-table data-stack-name="W07 Recap"}

* tldr: Moran's $I$ is to **GISers** what a thermometer is to a **doctors**:
    * Reveals **symptoms** only; many possible underlying **causes!**

## The Tree-Grid Mystery

* You've been hired as an archaeologist---congratulations! Your job: determine whether arrangement of **trees** formed:
  * **Naturally**, via a process of **resource competition**, or
  * **Artificially**, via an ancient civilization planting in a **grid**...

```{r}
#| label: tree-mystery
#| echo: false
#| code-fold: true
square_sf <- sf::st_as_sf(spatstat.geom::square(1))
grid_sf <- sf::st_as_sf(sf::st_make_grid(square_sf))
grid_buffer_sf <- grid_sf |> sf::st_buffer(dist=-0.01, singleSide = TRUE)
grid_points <- sf::st_sample(grid_buffer_sf, size=rep(1,100))
grid_ppp <- as.ppp(grid_points, W=spatstat.geom::square(1))
grid_ppp |> sf::st_as_sf() |> ggplot() +
  geom_sf() +
  theme_classic(base_size=24)
```

## Two Possible Histories...

<center>
Artificial
</center>

:::: {.columns}
::: {.column width="33%"}

```{r}
#| label: artificial-grid
#| code-fold: true
square_sf <- sf::st_as_sf(spatstat.geom::square(1))
grid_sf <- sf::st_as_sf(sf::st_make_grid(square_sf))
grid_buffer_sf <- grid_sf |> sf::st_buffer(dist=-0.01, singleSide = TRUE)
grid_buffer_sf |> ggplot() +
  geom_sf() +
  theme_classic(base_size=32)
```

:::
::: {.column width="33%"}

```{r}
#| label: artificial-grid-points
#| code-fold: true
grid_points <- sf::st_sample(grid_buffer_sf, size=rep(1,100))
grid_buffer_sf |> ggplot() +
  geom_sf() +
  geom_sf(data=grid_points) +
  theme_classic(base_size=32)
```

:::
::: {.column width="33%"}

```{r}
#| label: artificial-grid-result
#| code-fold: true
grid_ppp <- as.ppp(grid_points, W=spatstat.geom::square(1))
grid_ppp |> sf::st_as_sf() |> ggplot() +
  geom_sf() +
  theme_classic(base_size=32)
```

:::
::::

<center>
Natural
</center>

:::: {.columns}
::: {.column width="33%"}

```{r}
#| label: gen-trees
#| code-fold: true
r <- 0.05
pois_ppp <- rpoispp(150)
pois_sf <- pois_ppp |> sf::st_as_sf()
pois_sf |> ggplot() +
  geom_sf() +
  theme_classic(base_size=32)
```

:::
::: {.column width="33%"}

```{r}
#| label: kill-trees
#| code-fold: true
age <- runif(npoints(pois_ppp))
```

```{r}
pair_dists <- pairdist(pois_ppp)
close <- (pair_dists < r)
earlier <- outer(age, age, "<")
kill_younger <- apply(close & earlier, 1, any)
kill_younger
```

```{r}
pois_sf
```

```{r}
#pois_sf <- pois_sf |> mutate(kill_younger=kill_younger)
# pois_sf
# pois_sf |> ggplot() +
#   geom_sf() +
#   theme_classic(base_size=32)
```

:::
::: {.column width="33%"}

:::
::::

# Point Process Models {data-stack-name="Point Process Models"}

## *Why* Do Events Appear Where They Do? {.smaller .title-12 .inline-90}

```{r}
#| label: sr-plot
#| code-fold: true
#| output: false
library(tidyverse)
library(spatstat)
set.seed(6805)
N <- 60
r_core <- 0.05
obs_window <- square(1)
# Regularity via Inhibition
#reg_sims <- rMaternI(N, r=r_core, win=obs_window)
cond_reg_sims <- rSSI(r=r_core, N)
# CSR data
#csr_sims <- rpoispp(N, win=obs_window)
cond_sr_sims <- rpoint(N, win=obs_window)
### Clustered data
#clust_sims <- rMatClust(kappa=6, r=2.5*r_core, mu=10, win=obs_window)
#clust_sims <- rMatClust(mu=5, kappa=1, scale=0.1, win=obs_window, n.cond=N, w.cond=obs_window)
#clust_sims <- rclusterBKBC(clusters="MatClust", kappa=10, mu=10, scale=0.05, verbose=FALSE)
# Each cluster consist of 10 points in a disc of radius 0.2
nclust <- function(x0, y0, radius, n) {
    #print(n)
    return(runifdisc(10, radius, centre=c(x0, y0)))
}
cond_clust_sims <- rNeymanScott(kappa=5, expand=0.0, rclust=nclust, radius=2*r_core, n=10)
```

```{r}
#| label: intensity-est
#| code-fold: true
#| fig-width: 2
#| fig-height: 2
#| output: false
center_l_function <- function(x, ...) {
  if (!spatstat.geom::is.ppp(x) && !spatstat.geom::is.fv(x)) {
    stop("Please provide either ppp or fv object.")
  }
  if (spatstat.geom::is.ppp(x)) {
    x <- spatstat.explore::Lest(x, ...)
  }
  r <- x$r
  l_centered <- spatstat.explore::eval.fv(x - r)
  return(l_centered)
}
cond_clust_sf <- cond_clust_sims |> sf::st_as_sf()
pines_plot <- cond_clust_sf |>
  ggplot() +
  geom_sf() +
  dsan_theme("full")
ggsave("images/pines.png", pines_plot)
# density() calls density.ppp() if the argument is a ppp object
den <- density(cond_clust_sims, sigma = 0.1)
#summary(den)
png("images/intensity_plot.png")
plot(den, main = "Intensity λ(s)")
contour(den, add = TRUE) # contour plot
dev.off()
# And Kest / Lest
kest_result <- Kest(cond_clust_sims, rmax=0.5, correction="best")
lest_result <- center_l_function(cond_clust_sims, rmax=0.5)
png("images/lest.png")
plot(lest_result, main="K(h)")
dev.off()
```

| | First-Order | Second-Order |
|-|-|-|
| | Events considered **individually** $\implies$ **Intensity function $\lambda(\mathbf{s})$** | **Second-Order**: Events considered **pairwise** $\implies$ **$K$-function $K(\vec{h})$** |
| ![](images/pines.png) | ![](images/intensity_plot.png) | ![](images/lest.png) |

# A Menagerie of Models {data-stack-name="Point Process Models"}

## Poisson Point Processes (CSR)

## Simple Sequential Inhibition (SSI) Processes

## Matérn Cluster Processes

## Cox Processes: Random Points *plus* Random Intensity

# Fitting Models to Data {data-stack-name="Fitting Models"}

## Maximum Likelihood Estimation (MLE) Refresher

# Testing Hypotheses

## 

## References

::: {#refs}
:::
