---
title: "HW1 Hints"
author:
  name: "Jeff Jacobs"
  email: "jj1088@georgetown.edu"
date: 2025-09-19
sidebar: mainnav
categories:
  - Assignment Hints
cache: true
format:
  html:
    df-print: kable
    fig-align: center
    link-external-newwindow: true
    link-external-icon: true
    code-fold: show
---

There are a few points in HW1 which may be tricky if you haven't used R before, so this guide is here to provide you with some sample code that you can hopefully adapt for use in Questions 2 and 3!

## Question 2: Creating `sfg` (`sf` Geometry) Objects

Here, the trickiest part is probably figuring out exactly what **format** the `sf` library wants you to use when creating these geometry objects: the `sf` representations of `POINT`, `LINESTRING`, and `POLYGON`.

So, each subsection here will provide you with code explaining how to construct each of these three types of `sfg` objects out of three basic R data structures: **`vector`**, **`matrix`**, and **`list`**.

### Creating `POINT` objects with `sf_point()`

The syntax for creating `POINT` objects is the simplest of the three: since a `POINT` object in the [WKT schema](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) is literally just two numbers, we just need a way to "bundle together" two numbers and then provide this "bundle" to the `sf` library.

So, as was discussed in class and in the Coding Workshop, we can use the `c()` function from Base R to bundle together any number of objects (as long as they're all of the same type) into a **vector**:

```{r}
#| label: vector-examples
(my_numeric_vec <- c(1, 2, 3))
(my_character_vec <- c("a", "b", "c"))
(my_logical_vec <- c(TRUE, FALSE, TRUE))
```

With this knowledge, along with the fact that the `sf` library documentation says that the [`st_point()` function](https://r-spatial.github.io/sf/reference/st.html) takes in a **vector** as input, let's create a `POINT` object in R!

Since we also linked the Wikipedia page on [WKT geometry representations](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) above, let's use the examples from that page. Their example for a `POINT` looks like:

| | | |
|:-:|:-:|:-|
| `POINT` | ![](images/SFA_Point.svg) | `POINT (30 10)` |

And, the way we would create this `POINT` object in R (in a way that we could thus plot it or apply our unary/binary operations to it) looks as follows:

```{r}
#| label: wiki-point
# Load the sf library functions into R's memory
library(sf)
# Create a numeric vector containing the two coordinates
my_point_coords <- c(30, 10)
# Print out the contents of this numeric vector
print(my_point_coords)
# Print out the *class* (the datatype) of this vector, how it is stored in R
class(my_point_coords)
# Use the numeric vector as the *argument* to st_point(), to tell sf we want a POINT with these coordinates
my_point <- st_point(my_point_coords)
# Print out the *class* of this object, to see how sf has created an sfg (sf geometry) object
class(my_point)
```

We could also use `plot()` to plot an ultra-basic visual representation of this `POINT` we just created, `my_point`. It won't be very interesting, however, since the `plot()` function for `sfg` objects is meant to just quickly provide an as-simple-as-possible visual representation:

```{r}
#| label: plot-point
plot(my_point)
```

If we want to visualize the point **in its context** (in this case, in the context of the "standard" Cartesian $xy$-plane), we can turn to `ggplot2`, the Tidyverse data-visualization library, which will allow us to show the point within the broader $xy$-plane:

```{r}
#| label: plot-point-ggplot
library(tidyverse) |> suppressPackageStartupMessages()
my_point |> ggplot() +
  geom_sf() +
  theme_classic()
```

Much better! We can now see, using the information along the $x$ and $y$ axes, that this `sfg` object `my_point` specifically represents a **`POINT` object with $x$ coordinate of 30 and a $y$ coordinate of 10!**

### Creating `LINESTRING` Objects with `st_linestring()`

Next up is `LINESTRING`, which `sf` allows us to create using the **constructor** function `st_linestring()`. The example in the [Wikipedia article](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Geometric_objects) in this case looks like:

| | | |
|:-:|:-:|:-|
| `LINESTRING` | ![](images/SFA_LineString.svg) | `LINESTRING (30 10, 10 30, 40 40)` |

And from the WKT string on the right side, we can see how representing this type of geometry is going to require a slightly more complex **data structure** than the more simple **vector** we used above to represent the two coordinates of a single `POINT`.

In this case, looking at the [`sf` documentation](https://r-spatial.github.io/sf/reference/st.html), we can see that the `st_linestring()` constructor function requires a **`matrix`**, a datatype we haven't seen yet but which actually builds straightforwardly on top of the **vector** type that we have seen!

The `matrix` datatype in R is, I think, easiest to understand by looking at an example. Let's say we want to represent the matrix

$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix}
$$

within R. Above we saw how, to represent a **vector** like $(1, 2)$, we used the `c()` function in R: `c(1, 2)`. To represent a **matrix**, it turns out that we will **still use this `c()` function!** The syntax of `matrix` **takes a vector as input**, then transforms it into matrix form as follows:

* First we use `c()` to write out **all elements of the matrix, row by row, as a single "flat" vector**
* Then we **tell R how it should "split" this flat vector into rows and columns**

So, to represent the example matrix $A$ given above, in R, we implement these two steps as follows:

```{r}
#| label: example-matrix
# First we use c() to construct a *vector* containing all
# elements of the matrix in a single row (a "flattened" representation)
flattened_matrix <- c(1, 2, 3, 4, 5, 6)
flattened_matrix
# Then we provide this "flattened" vector to the matrix()
# constructor function, along with instructions for R on how
# to split it into rows and columns
example_matrix <- matrix(
  flattened_matrix,
  byrow = TRUE,
  nrow=2, ncol=3
)
example_matrix
```

And there's our example matrix from above, now encoded as an object of type `matrix` in R!

So, returning to our example from the Wikipedia article, since this `LINESTRING` consists of **3 coordinates** connected by straight lines, we now need to construct a matrix with **3 rows**, where each row contains the **coordinates of one point** in the `LINESTRING`. We can do this as follows, using the same syntax as in the previous code cell:

```{r}
#| label: linestring-matrix
my_linestring_matrix_flat <- c(30, 10, 10, 30, 40, 40)
my_linestring_matrix <- matrix(
  my_linestring_matrix_flat,
  byrow = TRUE,
  nrow=3, ncol=2
)
my_linestring_matrix
```

And now we have a `matrix` object in the form that `sf` requires for constructing an `st_linestring` object! All that's left is to plug this `linestring_matrix` object into the `st_linestring()` constructor function, as follows:

```{r}
#| label: construct-linestring
my_linestring_sf <- st_linestring(my_linestring_matrix)
my_linestring_sf
```

And we've successfully encoded the Wikipedia example into the `sf` library's `LINESTRING` representation! We can plot it quickly using `plot()` as we did earlier with the `st_point` object:

```{r}
#| label: plot-linestring
plot(my_linestring_sf)
```

And obtain a more interesting plot, showing our coordinate system, using `ggplot2`:

```{r}
#| label: plot-linestring-ggplot
my_linestring_sf |> ggplot() +
  geom_sf() +
  theme_classic()
```
